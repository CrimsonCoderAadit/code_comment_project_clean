Comments,Surrounding Code Context,Class
// Check if parentheses are balanced using stack approach,"bool balanced_parentheses(char* expr) { Stack stack; init_stack(&stack); for (int i = 0; expr[i]; i++) { if (expr[i] == '(' || expr[i] == '[' || expr[i] == '{') { push(&stack, expr[i]); } else if (expr[i] == ')' || expr[i] == ']' || expr[i] == '}') { if (is_empty(&stack)) return false; char top = pop(&stack); if (!is_matching_pair(top, expr[i])) return false; } } return is_empty(&stack); }",Useful
// Open file for reading,"FILE* fp = fopen(""data.txt"", ""r"");",Not Useful
// If condition is true,if (condition == true) { execute_code(); },Not Useful
// Euclidean algorithm for GCD - repeatedly applies division until remainder is zero,"int gcd(int a, int b) { while (b != 0) { int temp = b; b = a % b; a = temp; } return a; }",Useful
// Break from loop,if (found) break;,Not Useful
// Binary search implementation - returns index of target or -1 if not found,"int binary_search(int arr[], int n, int target) { int left = 0, right = n - 1; while (left <= right) { int mid = left + (right - left) / 2; if (arr[mid] == target) return mid; if (arr[mid] < target) left = mid + 1; else right = mid - 1; } return -1; }",Useful
// Sieve of Eratosthenes - efficiently finds all primes up to n by marking multiples,"void sieve_of_eratosthenes(int n) { bool prime[n + 1]; memset(prime, true, sizeof(prime)); for (int p = 2; p * p <= n; p++) { if (prime[p]) { for (int i = p * p; i <= n; i += p) prime[i] = false; } } for (int p = 2; p <= n; p++) { if (prime[p]) printf(""%d "", p); } }",Useful
// Merge two sorted linked lists into single sorted list,"struct Node* merge_sorted_lists(struct Node* l1, struct Node* l2) { if (!l1) return l2; if (!l2) return l1; if (l1->data <= l2->data) { l1->next = merge_sorted_lists(l1->next, l2); return l1; } else { l2->next = merge_sorted_lists(l1, l2->next); return l2; } }",Useful
// Calculate square root using Newton's method for approximation,"double sqrt_newton(double x, double precision) { if (x < 0) return -1; double guess = x / 2.0; while (fabs(guess * guess - x) > precision) { guess = (guess + x / guess) / 2.0; } return guess; }",Useful
// Find second largest element in array with single pass,"int second_largest(int arr[], int n) { int first = INT_MIN, second = INT_MIN; for (int i = 0; i < n; i++) { if (arr[i] > first) { second = first; first = arr[i]; } else if (arr[i] > second && arr[i] != first) { second = arr[i]; } } return second; }",Useful
// LRU cache implementation - maintains least recently used order with doubly linked list,"void lru_put(LRUCache* cache, int key, int value) { Node* node = hash_get(cache->map, key); if (node) { node->value = value; move_to_head(cache, node); } else { Node* new_node = create_node(key, value); if (cache->size >= cache->capacity) { Node* tail = remove_tail(cache); hash_remove(cache->map, tail->key); free(tail); cache->size--; } add_to_head(cache, new_node); hash_put(cache->map, key, new_node); cache->size++; } }",Useful
// Find least common multiple using GCD relationship,"int lcm(int a, int b) { return (a * b) / gcd(a, b); }",Useful
// Read input,"scanf(""%d"", &input);",Not Useful
// Variable declaration,"double temperature, pressure;",Not Useful
// Count number of set bits in integer using Brian Kernighan's algorithm,int count_set_bits(int n) { int count = 0; while (n) { n &= (n - 1); count++; } return count; },Useful
// Bit manipulation trick - swap two integers without temporary variable using XOR,"void swap_xor(int *a, int *b) { if (a != b && *a != *b) { *a ^= *b; *b ^= *a; *a ^= *b; } }",Useful
// Thread-safe counter using atomic operations to prevent race conditions,"void increment_counter(atomic_int* counter) { atomic_fetch_add(counter, 1); }",Useful
// Create struct,"struct Point { int x, y; };",Not Useful
// Update value,counter += increment;,Not Useful
// Comparison check,if (a > b) { max = a; } else { max = b; },Not Useful
// Merge sort merge function - combines two sorted subarrays into one sorted array,"void merge(int arr[], int left, int mid, int right) { int n1 = mid - left + 1; int n2 = right - mid; int L[n1], R[n2]; for (int i = 0; i < n1; i++) L[i] = arr[left + i]; for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j]; int i = 0, j = 0, k = left; while (i < n1 && j < n2) { if (L[i] <= R[j]) arr[k++] = L[i++]; else arr[k++] = R[j++]; } while (i < n1) arr[k++] = L[i++]; while (j < n2) arr[k++] = R[j++]; }",Useful
// Signal handler setup - properly handles SIGINT for graceful shutdown,"void setup_signal_handler() { struct sigaction sa; sa.sa_handler = sigint_handler; sigemptyset(&sa.sa_mask); sa.sa_flags = 0; if (sigaction(SIGINT, &sa, NULL) == -1) { perror(""sigaction""); exit(1); } }",Useful
// Convert string to integer with error handling for invalid input,"int string_to_int(const char* str, bool* success) { if (!str || !*str) { *success = false; return 0; } int result = 0, sign = 1; if (*str == '-') { sign = -1; str++; } while (*str) { if (*str < '0' || *str > '9') { *success = false; return 0; } result = result * 10 + (*str - '0'); str++; } *success = true; return result * sign; }",Useful
// Memory operation,"memset(buffer, 0, sizeof(buffer));",Not Useful
// Allocate memory with error checking - returns NULL if allocation fails,"int* create_array(int size) { if (size <= 0) return NULL; int *arr = malloc(size * sizeof(int)); if (arr == NULL) { fprintf(stderr, ""Memory allocation failed\n""); exit(1); } return arr; }",Useful
// Include header file,#include <stdio.h>,Not Useful
// While loop,while (i < 10) { process(i); i++; },Not Useful
// End of function,return 0; },Not Useful
// Allocate memory,ptr = malloc(size);,Not Useful
// Free linked list recursively to prevent memory leaks,void free_list(struct Node* head) { if (head == NULL) return; free_list(head->next); free(head); },Useful
// Find intersection of two sorted arrays using two pointers,"void find_intersection(int arr1[], int m, int arr2[], int n) { int i = 0, j = 0; while (i < m && j < n) { if (arr1[i] < arr2[j]) i++; else if (arr1[i] > arr2[j]) j++; else { printf(""%d "", arr1[i]); i++; j++; } } }",Useful
// Define constant,#define MAX_SIZE 100,Not Useful
// Loop iteration,for (int k = 0; k < size; k++) { array[k] = 0; },Not Useful
// Matrix multiplication with proper bounds checking,"void matrix_multiply(int A[][MAX], int B[][MAX], int C[][MAX], int rows_A, int cols_A, int cols_B) { for (int i = 0; i < rows_A; i++) { for (int j = 0; j < cols_B; j++) { C[i][j] = 0; for (int k = 0; k < cols_A; k++) { C[i][j] += A[i][k] * B[k][j]; } } } }",Useful
// CSV parser with quote handling - properly processes escaped commas and quotes,"char** parse_csv_line(char* line, int* field_count) { char** fields = malloc(MAX_FIELDS * sizeof(char*)); int count = 0; bool in_quotes = false; char* start = line; for (char* p = line; *p; p++) { if (*p == '""') in_quotes = !in_quotes; else if (*p == ',' && !in_quotes) { *p = '\0'; fields[count++] = start; start = p + 1; } } fields[count++] = start; *field_count = count; return fields; }",Useful
// Free memory,free(ptr);,Not Useful
// Check if array is sorted in ascending order,"bool is_sorted(int arr[], int n) { for (int i = 1; i < n; i++) { if (arr[i] < arr[i - 1]) return false; } return true; }",Useful
// String operation,"strcpy(dest, source);",Not Useful
// Find majority element using Boyer-Moore voting algorithm,"int find_majority(int arr[], int n) { int candidate = 0, count = 0; for (int i = 0; i < n; i++) { if (count == 0) candidate = arr[i]; count += (arr[i] == candidate) ? 1 : -1; } return candidate; }",Useful
// Find maximum element in array by iterating through all elements,"int find_max(int arr[], int n) { int max = arr[0]; for (int i = 1; i < n; i++) { if (arr[i] > max) max = arr[i]; } return max; }",Useful
// Bubble sort with early termination when no swaps occur,"void bubble_sort(int arr[], int n) { for (int i = 0; i < n - 1; i++) { bool swapped = false; for (int j = 0; j < n - i - 1; j++) { if (arr[j] > arr[j + 1]) { swap(&arr[j], &arr[j + 1]); swapped = true; } } if (!swapped) break; } }",Useful
// Some calculation,result = (a + b) * c - d;,Not Useful
// Count occurrences of character in string using linear scan,"int count_char(char* str, char c) { int count = 0; for (int i = 0; str[i]; i++) { if (str[i] == c) count++; } return count; }",Useful
// Prime number check using trial division up to square root,bool is_prime(int n) { if (n <= 1) return false; if (n <= 3) return true; if (n % 2 == 0 || n % 3 == 0) return false; for (int i = 5; i * i <= n; i += 6) { if (n % i == 0 || n % (i + 2) == 0) return false; } return true; },Useful
// Array rotation by k positions using reversal algorithm,"void rotate_array(int arr[], int n, int k) { k = k % n; reverse_array(arr, 0, n - 1); reverse_array(arr, 0, k - 1); reverse_array(arr, k, n - 1); }",Useful
// Boyer-Moore string search - skips characters using bad character heuristic for faster searching,"int boyer_moore_search(char* text, char* pattern) { int m = strlen(pattern); int n = strlen(text); int bad_char[256]; fill_bad_char_table(pattern, m, bad_char); int s = 0; while (s <= (n - m)) { int j = m - 1; while (j >= 0 && pattern[j] == text[s + j]) j--; if (j < 0) return s; else s += max(1, j - bad_char[text[s + j]]); } return -1; }",Useful
// Trie insertion - builds prefix tree for efficient string searching and autocomplete,"void insert_trie(struct TrieNode* root, char* word) { struct TrieNode* current = root; for (int i = 0; word[i]; i++) { int index = word[i] - 'a'; if (!current->children[index]) current->children[index] = create_trie_node(); current = current->children[index]; } current->is_end_of_word = true; }",Useful
// Call function,"result = calculate_total(values, count);",Not Useful
// Check if string is palindrome by comparing characters from both ends,bool is_palindrome(char* str) { int len = strlen(str); for (int i = 0; i < len / 2; i++) { if (tolower(str[i]) != tolower(str[len - 1 - i])) return false; } return true; },Useful
// Stack implementation with dynamic resizing to handle growth,"void stack_push(Stack* stack, int value) { if (stack->top >= stack->capacity - 1) { stack->capacity *= 2; stack->data = realloc(stack->data, stack->capacity * sizeof(int)); } stack->data[++stack->top] = value; }",Useful
// Important function,void update() { refresh_display(); save_state(); },Not Useful
// Start of main function,int main() {,Not Useful
// Socket setup with proper error handling and address reuse,"int create_server_socket(int port) { int sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd < 0) return -1; int opt = 1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)); struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_addr.s_addr = INADDR_ANY; addr.sin_port = htons(port); if (bind(sockfd, (struct sockaddr*)&addr, sizeof(addr)) < 0) { close(sockfd); return -1; } return sockfd; }",Useful
// Pointer assignment,char* ptr = buffer;,Not Useful
// Reverse string in-place using two pointers from both ends,void reverse_string(char* str) { int len = strlen(str); for (int i = 0; i < len / 2; i++) { char temp = str[i]; str[i] = str[len - 1 - i]; str[len - 1 - i] = temp; } },Useful
// Fast exponentiation using binary representation - O(log n) complexity instead of O(n),"long long fast_power(long long base, long long exp, long long mod) { long long result = 1; base = base % mod; while (exp > 0) { if (exp % 2 == 1) result = (result * base) % mod; exp = exp >> 1; base = (base * base) % mod; } return result; }",Useful
// Function body,"int compute(int x, int y) { return x * y + 5; }",Not Useful
// Handle case,case 2: execute_option2(); break;,Not Useful
// Conditional execution,if (enabled) execute_task();,Not Useful
// Initialize variables,"int a = 0, b = 0, c = 0;",Not Useful
// Hash table with linear probing - handles collisions by checking next slot,"int hash_insert(HashTable *table, int key, int value) { int index = hash_function(key) % table->size; while (table->entries[index].is_occupied) { if (table->entries[index].key == key) { table->entries[index].value = value; return 0; } index = (index + 1) % table->size; } table->entries[index].key = key; table->entries[index].value = value; table->entries[index].is_occupied = true; return 1; }",Useful
// Array initialization,int numbers[10] = {0};,Not Useful
// Binary tree height calculation using recursive depth-first approach,"int tree_height(struct Node* root) { if (root == NULL) return -1; int left_height = tree_height(root->left); int right_height = tree_height(root->right); return 1 + max(left_height, right_height); }",Useful
// Print number,"printf(""%d"", num);",Not Useful
// Loop through array,for (int j = 0; j < length; j++) { sum += numbers[j]; },Not Useful
// Continue loop,if (skip) continue;,Not Useful
// Else clause,} else { handle_alternative(); },Not Useful
// Increment i,"for (int i = 0; i < n; i++) { printf(""%d "", arr[i]); }",Not Useful
// Fibonacci sequence using iterative approach to avoid recursion overhead,"int fibonacci(int n) { if (n <= 1) return n; int a = 0, b = 1, result; for (int i = 2; i <= n; i++) { result = a + b; a = b; b = result; } return result; }",Useful
// Data processing,output = transform(input);,Not Useful
// Do something,void process() { calculate_result(); display_output(); },Not Useful
// Main logic here,if (status == READY) { begin_processing(); } else { wait_for_ready(); },Not Useful
// Mathematical operation,area = length * width;,Not Useful
// Safe string copy with bounds checking to prevent buffer overflow,"void safe_strcpy(char *dest, const char *src, size_t dest_size) { if (dest == NULL || src == NULL || dest_size == 0) return; strncpy(dest, src, dest_size - 1); dest[dest_size - 1] = '\0'; }",Useful
// Remove duplicates from sorted array by overwriting with unique elements,"int remove_duplicates(int arr[], int n) { if (n == 0) return 0; int j = 0; for (int i = 1; i < n; i++) { if (arr[i] != arr[j]) { j++; arr[j] = arr[i]; } } return j + 1; }",Useful
// Print hello,"void print_hello() { printf(""Hello, World!\n""); }",Not Useful
// This is code,int process_data(char* buffer) { return strlen(buffer); },Not Useful
// AVL tree rotation to maintain balance - left rotation for right-heavy subtree,"struct Node* rotate_left(struct Node* x) { struct Node* y = x->right; struct Node* T2 = y->left; y->left = x; x->right = T2; x->height = 1 + max(height(x->left), height(x->right)); y->height = 1 + max(height(y->left), height(y->right)); return y; }",Useful
// Floyd's cycle detection algorithm - detects loops in linked lists using two pointers,"bool has_cycle(struct Node* head) { struct Node *slow = head, *fast = head; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow == fast) return true; } return false; }",Useful
// Process input,validate_input(data); transform_data(data); store_result(data);,Not Useful
// Close file,fclose(file);,Not Useful
// Assign value,value = 42;,Not Useful
// Check if x equals 0,"if (x == 0) { printf(""Zero\n""); } else { printf(""Non-zero\n""); }",Not Useful
// Switch statement,switch (option) { case 1: handle_option1(); break; },Not Useful
// Function declaration,"int calculate(int a, int b);",Not Useful
// Robust file reading with error handling and proper resource cleanup,"char* read_file(const char* filename) { FILE* file = fopen(filename, ""r""); if (!file) { perror(""fopen""); return NULL; } fseek(file, 0, SEEK_END); long size = ftell(file); rewind(file); char* buffer = malloc(size + 1); if (!buffer) { fclose(file); return NULL; } fread(buffer, 1, size, file); buffer[size] = '\0'; fclose(file); return buffer; }",Useful
// Return the sum,"int add(int a, int b) { return a + b; }",Not Useful
// Set x to 1,int x = 1;,Not Useful
// Queue implementation using circular array with full/empty detection,"bool queue_enqueue(Queue* q, int data) { if ((q->rear + 1) % q->capacity == q->front) return false; q->data[q->rear] = data; q->rear = (q->rear + 1) % q->capacity; return true; }",Useful
// Exit program,exit(0);,Not Useful
// Declare integer variable,int counter;,Not Useful
// Circular buffer implementation - overwrites oldest data when full,"void circular_buffer_put(CircularBuffer* cb, int data) { cb->buffer[cb->head] = data; cb->head = (cb->head + 1) % cb->size; if (cb->count < cb->size) cb->count++; else cb->tail = (cb->tail + 1) % cb->size; }",Useful
// Return statement,return result;,Not Useful
// Allocate 2D array with proper cleanup on partial failure,"int** allocate_2d_array(int rows, int cols) { int **arr = malloc(rows * sizeof(int*)); if (!arr) return NULL; for (int i = 0; i < rows; i++) { arr[i] = malloc(cols * sizeof(int)); if (!arr[i]) { for (int j = 0; j < i; j++) free(arr[j]); free(arr); return NULL; } } return arr; }",Useful
// Calculate power using iterative multiplication for positive exponents,"double power(double base, int exp) { if (exp < 0) return 1.0 / power(base, -exp); double result = 1.0; for (int i = 0; i < exp; i++) { result *= base; } return result; }",Useful
// Quick sort partition function - places pivot in correct position and returns partition index,"int partition(int arr[], int low, int high) { int pivot = arr[high]; int i = low - 1; for (int j = low; j < high; j++) { if (arr[j] < pivot) { i++; swap(&arr[i], &arr[j]); } } swap(&arr[i + 1], &arr[high]); return i + 1; }",Useful
// Thread pool worker function - continuously processes tasks from queue,"void* worker_thread(void* arg) { ThreadPool* pool = (ThreadPool*)arg; while (1) { pthread_mutex_lock(&pool->mutex); while (pool->queue_size == 0 && !pool->shutdown) { pthread_cond_wait(&pool->condition, &pool->mutex); } if (pool->shutdown) break; Task task = pool->queue[pool->queue_front]; pool->queue_front = (pool->queue_front + 1) % pool->queue_capacity; pool->queue_size--; pthread_mutex_unlock(&pool->mutex); task.function(task.arg); } return NULL; }",Useful
// Calculate factorial recursively with base case n <= 1,int factorial(int n) { if (n <= 1) return 1; return n * factorial(n - 1); },Useful
// Dijkstra's shortest path algorithm - finds minimum distance from source to all vertices,"void dijkstra(int graph[V][V], int src) { int dist[V]; bool sptSet[V]; for (int i = 0; i < V; i++) { dist[i] = INT_MAX; sptSet[i] = false; } dist[src] = 0; for (int count = 0; count < V - 1; count++) { int u = minDistance(dist, sptSet); sptSet[u] = true; for (int v = 0; v < V; v++) { if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) dist[v] = dist[u] + graph[u][v]; } } }",Useful
// Code goes here,void initialize() { setup_environment(); load_configuration(); },Not Useful
